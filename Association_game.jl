using StatsBase
using Random
using Base.Threads


include("Semantic_networks.jl")
using .Semantic_networks

function differences(A::AbstractArray{Float32, 3}; sums=nothing)::Matrix{Float64}
    """
    Calculates the Total Variation Distance (TVD), or Normalized Manhattan Distance, 
    between all pairs of semantic networks stored in the 3D array 'A'. 
    The calculation is performed in parallel.
    The formula computed is 0.5 * sum(|A_i/sum(A_i) - A_j/sum(A_j)|), where A_i is a slice of A.
    
    # Arguments
    - `A`: A 3D array (n x n x num_participants) containing the semantic networks.
    - `sums`: (Optional) Pre-calculated sum of all elements in each network slice, for performance.
    - `convert_to_float32`: Converts arrays to Float32 for faster memory access/computation.
    # Returns
    - A symmetric matrix (num_participants x num_participants) of Float64 distances.
    """
    @assert ndims(A) == 3
    n, _, num = size(A)
    sums64 = if isnothing(sums)
        [sum(@view A[:, :, k]) for k in 1:num]
    else
        Float64.(sums)
    end
    @assert all(sums64 .> 0)

    invs = 1.0 ./ sums64
    D = Matrix{Float64}(undef, num, num)

    @inbounds for i in 1:num
        D[i, i] = 0.0
    end
    Threads.@threads for i in 1:num-1
        Ai   = @view A[:, :, i]
        invA = invs[i]
        for j in i+1:num
            Aj   = @view A[:, :, j]
            invB = invs[j]
            acc = mapreduce(k -> abs(invA * Ai[k] - invB * Aj[k]),
                            +,
                            eachindex(Ai))
            d = 0.5 * acc
            @inbounds begin
                D[i, j] = d
                D[j, i] = d
            end
        end
    end

    return D
end

function self_conversation!(participant, L, n, deltas)
    """
    Simulates a private, self-contained conversation (self-talk) for a single participant.
    The participant's knowledge structure (network) is updated based on the generated associations.
    # Arguments
    - `participant`: The participant's n x n semantic network matrix (updated in-place).
    - `L`: The length (number of turns) of the conversation.
    - `n`: Total number of nodes (words).
    - `deltas`: Vector storing the specific changes made (couples of nodes and weight change).
    """
    cue = sample(1:n, Weights(vec(sum(participant, dims=1))))
    @inbounds for l in 1:L
        association = sample(1:n, Weights(view(participant, :, cue)))
        participant[cue, association] += 1
        participant[association, cue] += 1
        push!(deltas, (cue, association, 1))
        push!(deltas, (association, cue, 1))
        cue = association
    end
end

function circle_conversation!(participants, idxs, L, n, deltas)
    """
    Simulates a circular conversation among a group of participants. 
    The associations generated by the speakers update the semantic networks of *all* participants in the group.
    
    # Arguments
    - `participants`: The full 3D array of all networks (n x n x num). (Updated in-place)
    - `idxs`: Indices of the participants currently involved in the joint conversation.
    - `L`: The length (number of turns) of the conversation.
    - `n`: Total number of nodes (words).
    - `deltas`: Dictionary storing the changes made per participant for later distance updates.
    """
    number = length(idxs)
    speaker_idx = idxs[rand(1:number)]
    cue = sample(1:n, Weights(sum(participants[:, :, speaker_idx], dims=1)[:]))
    @inbounds for l in 1:L
        speaker_idx = idxs[mod1(findfirst(isequal(speaker_idx), idxs)+1, number)]
        association = sample(1:n, Weights(view(participants, :, cue, speaker_idx)))
        for p in idxs
            participants[cue, association, p] += 1
            participants[association, cue, p] += 1
            push!(deltas[p], (cue, association, 1))
            push!(deltas[p], (association, cue, 1))
        end
        cue = association
    end
end

function update_distances_same!(D::AbstractMatrix{Float32},idxs::Vector{Int},old_mass::Real,new_mass::Real)
    """
    This function updates the distance matrix 'D' for pairs where *both* participants 
    (i and j) were involved in the joint conversation (idxs). 
    The function **drastically reduces computation time** by avoiding a full re-calculation 
    of the TVD/Manhattan distance. 
    The mechanism relies on a key assumption of the model: **the total mass (sum of all edge weights) is identical across all participants throughout the game.** This is because the total mass added per turn (2L) is the same for every participant, regardless of whether they were in the joint conversation or the self-conversation.
    Therefore, the only change needed for these pairs is a simple **normalization** by the ratio of mass increase.
    # Arguments
    - `D`: The distance matrix (updated in-place).
    - `idxs`: Indices of participants in the joint conversation.
    - `old_mass`: Total sum of all edge weights before the turn.
    - `new_mass`: Total sum of all edge weights after the turn.
    """
    @inbounds for i in 1:length(idxs)
        for j in i+1:length(idxs)
            a, b = idxs[i], idxs[j]
            d = D[a,b] * (old_mass / new_mass)
            D[a,b] = d
            D[b,a] = d
        end
    end
end

function update_distances_partial!(D::AbstractMatrix{Float32},participants::AbstractArray{<:Real,3},deltas::Dict{Int, Vector{NTuple{3,Int}}}, idxs::AbstractVector{<:Integer},old_mass::Real,new_mass::Real,)
    """
    Updates the distance matrix 'D' incrementally for pairs where **at least one** participant 
    (a or b) was NOT in the joint conversation.
    This function is essential for pairs that did *not* participate together, as the 
    specific changes in their networks (deltas) are unique, requiring an **incremental 
    re-calculation of the Manhattan Sum**.
    
    # Mechanism (Incremental Update):
    The function uses the previously calculated denormalized Manhattan Sum (S_old) and 
    applies the deltas (changes) to it:
    1.  **Rollback:** The absolute difference between the networks *before* the changes (abs(diff_before)) is subtracted from S_old.
    2.  **Roll-Forward:** The absolute difference between the networks *after* the changes     (abs(diff_after)) is added to S_old.
    3.  **Final Normalization:** The resulting updated sum (S_old) is then normalized by the new total mass (`nm`) to yield the new TVD/distance.
    # Arguments
    - `D`: The distance matrix (updated in-place).
    - `participants`: The full 3D array of networks.
    - `deltas`: Dictionary of *specific* changes (node couples and weight change) made in the current turn for each participant.
    - `idxs`: Indices of participants in the joint conversation (used for exclusion logic).
    - `old_mass`: Total sum of all edge weights before the turn.
    - `new_mass`: Total sum of all edge weights after the turn.
    """
    
    num = size(participants, 3)
    om  = float(old_mass)
    nm  = float(new_mass)

    in_joint = falses(num)
    @inbounds in_joint[idxs] .= true

    @inbounds for a in 1:num
        for b in a+1:num
            if !(in_joint[a] & in_joint[b])
                da = deltas[a]
                db = deltas[b]
                S_old = D[a,b] * om * 2
                counts_a = Dict{Tuple{Int,Int}, Int}()
                counts_b = Dict{Tuple{Int,Int}, Int}()
                for (x,y,δ) in da
                    counts_a[(x,y)] = get(counts_a, (x,y), 0) + δ
                end
                for (x,y,δ) in db
                    counts_b[(x,y)] = get(counts_b, (x,y), 0) + δ
                end

                acc = 0.0
                for key in union(keys(counts_a), keys(counts_b))
                    x, y = key
                    add_a = get(counts_a, key, 0)
                    add_b = get(counts_b, key, 0)
                    if add_a != 0 || add_b != 0
                        val_a_after = float(@inbounds participants[x, y, a])
                        val_b_after = float(@inbounds participants[x, y, b])
                        val_a_before = val_a_after - add_a
                        val_b_before = val_b_after - add_b
                        diff_after  = val_a_after - val_b_after
                        diff_before = val_a_before - val_b_before
                        S_old -= abs(diff_before)
                        S_old += abs(diff_after)
                    end
                end
                D[a,b] = 0.5 * S_old / nm
                D[b,a] = D[a,b]
            end
        end
    end
end

function association_game(num,turns,n,m,L,num_out,lambda,start_participants,distance_matrix_start;game_version)
    """
    The main simulation function for the semantic learning game. It simulates 'turns' of interaction,
    updates participant networks, and tracks the evolving distance matrix based on the chosen selection model.
    
    # Arguments
    - `num`: Total number of participants.
    - `turns`: Total number of simulation steps (turns).
    - `n`: Total number of nodes (words) in the networks.
    - `m`: Number of initial connections per new node (network parameter).
    - `L`: Length of each conversation (number of association steps).
    - `num_out`: Number of participants excluded from the joint conversation each turn.
    - `lambda`: Sensitivity parameter (λ) for the homophily model (used only when game_version="homophily").
    - `start_participants`: The initial 3D array of participant networks.
    - `distance_matrix_start`: The initial distance matrix (n x n).
    - `game_version`: The interaction model to use ("random", "isolation", or "homophily").
    
    # Returns
    - A tuple: (out_indices, distance_matrices_array).
    * `out_indices` (Vector{Int}): A chronological list of participant indices that were 
    excluded from the joint conversation at each step. This vector's length will be `turns` * `num_out`.
    * `distance_matrices_array` (Array{Float32, 3}): A 3D array storing the full distance matrix (num x num) at the beginning of the simulation (index 1) and after every turn 
    (indices 2 to turns+1). Its dimensions are `num x num x (turns + 1)`.
    """
    mas=(m*(m-1))+(n-m)*m*2
    delta_mass = 2L
    participants=copy(start_participants)
    distance_matrices = Array{Float32,3}(undef, num, num, turns+1)
    distance_matrix   = Float32.(distance_matrix_start)
    distance_matrices[:, :, 1] .= distance_matrix
    out = Int[]
    if game_version=="random"
        for turn in 1:turns
            old_mass = mas + delta_mass*(turn-1)
            new_mass = old_mass + delta_mass
            idxs = shuffle(1:num)[1:num-num_out]
            outs=setdiff(1:num,idxs)
            append!(out, outs)
            deltas = Dict{Int, Vector{NTuple{3,Int}}}()
            for p in 1:num
                deltas[p] = Vector{NTuple{3,Int}}()
            end
            circle_conversation!(participants, idxs, L, n, deltas)
            for p in outs
                self_conversation!(view(participants, :, :, p), L, n, deltas[p])
            end
            update_distances_same!(distance_matrix, idxs, old_mass, new_mass)
            update_distances_partial!(distance_matrix, participants, deltas,idxs, old_mass, new_mass)
            distance_matrices[:, :, turn+1] .= distance_matrix
        end
    elseif game_version=="isolation"
        idxs = shuffle(1:num)[1:num-num_out]
        outs=setdiff(1:num,idxs)
        for turn in 1:turns
            old_mass = mas + delta_mass*(turn-1)
            new_mass = old_mass + delta_mass
            deltas = Dict{Int, Vector{NTuple{3,Int}}}()
            for p in 1:num
                deltas[p] = Vector{NTuple{3,Int}}()
            end
            circle_conversation!(participants, idxs, L, n, deltas)
            for p in outs
                self_conversation!(view(participants, :, :, p), L, n, deltas[p])
            end
            update_distances_same!(distance_matrix, idxs, old_mass, new_mass)
            update_distances_partial!(distance_matrix, participants, deltas,idxs, old_mass, new_mass)
            distance_matrices[:, :, turn+1] .= distance_matrix
        end
    elseif game_version=="homophily"
        for turn in 1:turns
            old_mass = mas + delta_mass*(turn-1)
            new_mass = old_mass + delta_mass
            who_plays=Int[]
            allowed = trues(num)
            chooses=rand(1:num)
            push!(who_plays,chooses)
            allowed[chooses] = false
            for choice in 1:(num-num_out-1)
                candidates = findall(allowed)
                weights = exp.(-lambda .* distance_matrix[candidates, chooses])
                weights ./= sum(weights)
                chooses = sample(candidates, Weights(weights))
                push!(who_plays, chooses)
                allowed[chooses] = false
            end
            outs = findall(allowed)
            append!(out, outs)
            deltas = Dict{Int, Vector{NTuple{3,Int}}}()
            for p in 1:num
                deltas[p] = Vector{NTuple{3,Int}}()
            end
            circle_conversation!(participants, who_plays, L, n, deltas)
            for p in outs
                self_conversation!(view(participants, :, :, p), L, n, deltas[p])
            end
            update_distances_same!(distance_matrix, who_plays, old_mass, new_mass)
            update_distances_partial!(distance_matrix, participants, deltas,who_plays, old_mass, new_mass)
            distance_matrices[:, :, turn+1] .= distance_matrix
        end
    else
        error("❌ Error: Unknown game_version '$game_version'. Must be 'random', 'isolation', or 'homophily'.")
    end
    return out,distance_matrices
end

# ------------------------------------------------------------
# PARAMETER DEFINITIONS (EXPERIMENTAL CONDITIONS)
# ------------------------------------------------------------

num         = 30       # N: Total number of participants/agents in the simulation.
n           = 5018     # Total number of nodes (words/concepts) in each semantic network.
m           = 11       # Number of connections each new node forms (key parameter for network growth).
L           = 400      # Length of each conversation (L steps of association in one turn).
num_out     = 1        # Number of participants excluded from the joint conversation per turn.
turns       = 250      # Total number of simulation turns (time steps).
change      = 0.4      # Ratio of randomized nodes (1 - fixed_ratio) when creating initial participants.
lambda      = 30       # Lambda (λ): Sensitivity parameter for the homophily selection model.

# ------------------------------------------------------------
# INITIALIZATION
# ------------------------------------------------------------

# 1. Generate the initial heterogeneous participant networks based on the 'change' ratio.
participants = Semantic_networks.make_participants(num, n, m, change) 

# 2. Calculate the initial distance matrix (TVD) between all participant networks.
distance_matrix_start = differences(participants) 

# ------------------------------------------------------------
# SIMULATION RUNS (EXPERIMENTAL CONDITIONS)
# ------------------------------------------------------------

# 1. Homophily Model: Participants are selected based on high similarity (low distance, high lambda).
homophily_game = association_game(num, turns, n, m, L, num_out, lambda, 
                                  participants, distance_matrix_start; game_version="homophily")

# 2. Random Model: Participants are selected randomly each turn (baseline for comparison).
random_game = association_game(num, turns, n, m, L, num_out, lambda, 
                               participants, distance_matrix_start; game_version="random")

# 3. Isolation Model: The excluded group is determined once and remains fixed throughout the game.
isolation_game = association_game(num, turns, n, m, L, num_out, lambda, 
                                  participants, distance_matrix_start; game_version="isolation")